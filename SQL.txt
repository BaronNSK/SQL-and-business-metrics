Первым всегда будет отрабатывать оператор FROM, потому что перед тем как начинать работать с данными, нам необходимо указать источник этих данных.
После него всегда будет отрабатывать оператор WHERE, так как, после того как мы указали источник данных, нам необходимо его отфильтровать.
И только после того, как мы отфильтровали данные, они передаются в оператор SELECT, и там уже мы сможем выбрать столбцы, которые нам необходимы, и вывести их на экран.
Например, если мы в SELECT указываем столбец с псевдонимом (SELECT event_name AS Название_события), то когда мы прописываем условие WHERE мы должны указывать столбец без псевдонима (WHERE event_name = 'app_first_launch'), так как он выполняется раньше, иначе словим ошибку.

SELECT COUNT(*)
FROM game_events
Такой запрос всегда вернет только одно значение – количество строк в таблице, которая указана во FROM

Назовите четыре основных типа соединения в SQL
Чтобы объединить две таблицы в одну, следует использовать оператор JOIN. Соединение таблиц может быть внутренним (INNER) или внешним (OUTER), причём внешнее соединение может быть левым (LEFT), правым (RIGHT) или полным (FULL).
•	INNER JOIN — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
•	FULL OUTER JOIN — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
•	LEFT JOIN — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
•	RIGHT JOIN — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
 
А что такое Self JOIN?
Такой вопрос тоже может прозвучать на собеседовании по SQL. Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.
Например, следующий SQL-запрос объединяет клиентов из одного города:
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;
 
Для чего нужен оператор UNION?
Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в том же порядке.
Пример использования:
SELECT column(s) FROM first_table
UNION
SELECT column(s) FROM second_table;

Работа с базами данных
1.	SHOW DATABASES:
•	Получение списка всех доступных баз данных.
•	Пример:
SHOW DATABASES;
2.	CREATE DATABASE:
•	Создание новой базы данных.
•	Пример:
CREATE DATABASE mydb;
3.	DROP DATABASE:
•	Удаление существующей базы данных и всех её данных.
•	Пример:
DROP DATABASE mydb;
4.	USE DATABASE:
•	Выбор базы данных, с которой вы хотите работать (активировать).
•	Пример: USE mydb; 
Работа с таблицами
1.	CREATE TABLE:
•	Создание новой таблицы.
•	Пример:
CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOTNULL, email VARCHAR(100) UNIQUE, birthdate DATE );
2.	DROP TABLE:
•	Удаление таблицы и всех её данных.
•	Пример:
DROP TABLE users;
3.	DESCRIBE (или DESC):
•	Получение информации о структуре таблицы.
•	Пример:
DESCRIBE users;
4.	INSERT INTO:
•	Вставка новых записей в таблицу.
•	Пример:
INSERT INTO users (username, email, birthdate) VALUES ('john_doe', 'john@example.com', '1990-05-15');
5.	DELETE:
•	Удаление записей из таблицы.
•	Пример:
DELETE FROM users WHERE id = 1;
6.	UPDATE:
•	Обновление данных в таблице.
•	Пример:
UPDATE users SET email = 'new_email@example.com' WHERE id = 2;
7.	ALTER TABLE:
•	Изменение структуры существующей таблицы.
•	Примеры:
•	Добавление нового столбца:
ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
•	Изменение типа столбца:
ALTER TABLE users MODIFY COLUMN phone_number INT;
•	Удаление столбца:
ALTER TABLE users DROP COLUMN birthdate;


Базовые понятия SQL
SQL (Structured Query Language) - это язык структурированных запросов, используемый для управления и манипулирования данными в реляционных базах данных. Вот некоторые базовые понятия SQL:
1.	Таблицы: Таблицы представляют собой основные объекты хранения данных в базе данных. Они состоят из столбцов (атрибутов) и строк (записей), где каждая строка представляет отдельную запись данных.
2.	Запросы (Queries): Запросы SQL используются для извлечения данных из базы данных. Наиболее распространенный тип запроса - это SELECT-запрос, который позволяет выбирать определенные данные из одной или нескольких таблиц.
3.	Операторы SELECT, INSERT, UPDATE, DELETE: SELECT используется для выборки данных, INSERT - для добавления новых записей, UPDATE - для обновления существующих записей, а DELETE - для удаления записей.
4.	Условия (Conditions): Условия в SQL используются для фильтрации данных при выполнении запросов. Например, оператор WHERE позволяет указывать условия, которым должны удовлетворять выбираемые строки.
5.	Операторы сравнения: Операторы сравнения, такие как "=", ">", "<", ">=", "<=", "!=", позволяют сравнивать значения в запросах и условиях.
6.	Операторы логических связок: Операторы логических связок, такие как AND, OR, NOT, используются для комбинирования условий в запросах.
7.	Сортировка (Sorting): Оператор ORDER BY используется для сортировки результатов запроса по определенному столбцу или набору столбцов.
8.	Группировка (Grouping): Оператор GROUP BY используется для группировки данных по определенным столбцам. Обычно он используется с агрегатными функциями, такими как SUM, AVG, COUNT и др., чтобы выполнить вычисления над группами данных.
9.	Соединения (Joins): Соединения используются для объединения данных из нескольких таблиц на основе общих значений ключевых столбцов.
10.	Индексы (Indexes): Индексы в SQL создаются для ускорения процесса поиска и извлечения данных из базы данных. Они представляют собой структуры данных, которые позволяют быстрый доступ к определенным записям в таблице.
CHAR_LENGTH(…) – количество символов.
 Чтобы проверить, есть ли ключевое слово в заголовке шага, можно использовать функцию:
INSTR(string_1, string_2)
которая возвращает позицию первого вхождения string_2 в string_1. Если вхождения нет - результат функции 0.
REGEXP позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане REGEXP представляет более изощренный и комплексный способ фильтрации, нежели оператор LIKE. Это ссылка на документацию.
REGEXP имеет похожий синтаксис:
WHERE выражение [NOT] REGEXP регулярное выражение
Регулярное выражение может принимать следующие специальные символы:
•	^   указывает на начало строки
•	$   указывает на конец строки
•	.    соответствует любому одиночному символу
•	[символы]    соответствует любому одиночному символу из квадратных скобок
•	[начальный_символ-конечный_символ]: соответствует любому одиночному символу из диапазона символов
•	|     отделяет два шаблона строки, и значение должно соответствовать одному из этих шаблонов
Примеры REGEXP:
•	WHERE ProductName REGEXP 'Phone': строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone
•	WHERE ProductName REGEXP '^Phone': строка должна начинаться с "Phone", например, Phone 34, PhoneX
•	WHERE ProductName REGEXP 'Phone$': строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone
•	WHERE ProductName REGEXP 'iPhone [78]';: строка должна содержать либо iPhone 7, либо iPhone 8
•	WHERE ProductName REGEXP 'iPhone [6-8]';: строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8
Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
SELECT * FROM Products
WHERE ProductName REGEXP 'Phone|Galaxy';

ORDER BY FIELD(название_столбца, ‘текст’, ‘текст2’) – укажет, в каком порядке отсортировать, если нужно не по алфавиту.


BigQuery - это облачное хранилище данных и аналитический инструмент, который позволяет обрабатывать и анализировать большие объемы данных с высокой скоростью. Он имеет ряд преимуществ для аналитиков:
1.	Быстрый доступ к данным: BigQuery может обрабатывать многотерабайтные наборы данных за несколько секунд.
2.	Масштабируемость: BigQuery может масштабироваться вертикально и горизонтально, что позволяет аналитикам управлять большими объемами данных.
3.	Совместимость: BigQuery поддерживает стандартные SQL-запросы, поэтому аналитики могут использовать стандартные инструменты и библиотеки.
4.	Разделение прав доступа: BigQuery позволяет аналитикам определять различные уровни доступа к данным, что обеспечивает безопасность и конфиденциальность.
Интеграция Google Analytics 4 и BigQuery позволяет аналитикам получить полный доступ к своим данным Google Analytics 4 в BigQuery, что дает дополнительные преимущества:
1.	Увеличение гибкости анализа: BigQuery позволяет аналитикам проводить более сложные и гибкие анализы данных Google Analytics 4.
2.	Обогащение данных: BigQuery позволяет аналитикам объединять данные из различных источников для создания более полной картины.
3.	Больше возможностей для визуализации: BigQuery предоставляет аналитикам больше возможностей для визуализации данных, что делает результаты анализа более наглядными и понятными.
Однако, есть несколько нюансов, которые нужно учитывать при работе с этой интеграцией. В частности:
1.	Нужно иметь хорошее понимание SQL-запросов, чтобы эффективно использовать BigQuery.
2.	Работа с большими объемами данных может быть затруднительной, если у вас нет достаточного количества ресурсов для обработки данных.
3.	Необходимость подготовки правильных запросов для извлечения нужной информации из больших объемов данных.
4.	Возможные дополнительные затраты на использование сервисов облачных вычислений.
Таким образом, интеграция Google Analytics 4 и BigQuery предоставляет аналитикам новые возможности для работы с данными и расширения аналитических возможностей. Однако, ее использование требует определенного уровня знаний и навыков работы с SQL-запросами и обработкой больших объемов данных.
Ссылка - console.cloud.google.com

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции RAND(). Если эту функцию умножить на 365, то она будет генерировать вещественные числа от 0 до 365 (не включительно). Осталось только отбросить дробную часть. Это можно сделать с помощью функции FLOOR(), которая возвращает наибольшее целое число, меньшее или равное указанному числовому значению. Таким образом, случайное число от 0 до 365 можно получить с помощью выражения:
FLOOR(RAND() * 365)
Для сложения  даты с числом используется функция:
DATE_ADD(дата, INTERVAL число единица_измерения),

где
  единица_измерения (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
  число – целое число,
  дата – значение даты или даты и времени.
Функция к дате  прибавляет указанное число, выраженное в днях, месяцах и пр. , в зависимости от заданного интервала, и возвращает новую дату.
Например:
DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года
DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года
SELECT Now() – покажет текущие дату и время.

Для удаления таблицы используется SQL запрос DROP:
DROP TABLE таблица;

Памятка о типичных ошибках и способах их исправления
Эта памятка написана, чтобы помочь Вам самостоятельно находить ошибки в своих запросах. Если ваш запрос не принимается системой, то возвращайтесь на эту страничку и пройдитесь по всем пунктам:
1. Приведите синтаксис запроса к общепринятому:
•	если у вас есть время, стоит изучить руководство по стилю SQL https://www.sqlstyle.guide/ru/
•	можете отформатировать ваш запрос с помощью, например, https://codebeautify.org/sqlformatter
2. Проверьте, что ключевые слова, названия столбцов и значения в ячейках, которые необходимо найти, написаны правильно. Особенно обратите внимание, чтобы в русских названиях столбцов не было английских букв.
3. Проверьте, что:
•	количество открывающихся скобок равно количеству закрывающихся;
•	запятые разделяют перечисление столбцов, но не ключевые слова;
•	запросы разделяются точкой с запятой.
4. Проверьте, что последовательность команд указана верно (она отличается от последовательности выполнения команд в запросе):
SELECT 'столбцы или * для выбора всех столбцов; обязательно'

FROM 'таблица; обязательно'

WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'

GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'

HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'

ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
5.  Если запрос включает подзапросы, выполните сначала подзапросы и удостоверьтесь, что получаете ожидаемый результат.
6. Прочитайте комментарии под заданием: большинство трудностей уже обсуждалось не один раз.

 
Основные принципы реляционных баз данных:
•	все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
•	в пересечение строки и столбца таблицы можно занести только одно значение;
•	все операции выполняются над целыми отношениями и результатом этих операций является отношение.
Пример отношения: 
                          
На примере таблицы Сотрудник рассмотрим терминологию реляционных баз данных:
•	отношение  – это структура данных целиком, набор записей (в обычном понимании – таблица) , в  примере –это Сотрудник;
•	кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А, 234-01-23, программист>, все кортежи в отношении должны быть различны;
•	мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
•	атрибут – это столбец в таблице (более распространенный термин – поле ), в примере – Табельный номер, Фамилия И.О., Телефон, Должность) 
•	размерность – это число атрибутов в таблице, в данном случае – 4;
•	размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
•	 домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута Должность домен – {инженер, программист}.
 
Основные типы данных SQL:
Тип данных	Описание	Пример
INT 
INTEGER	Целое число, могут принимать значения
от -2 147 483 648 до 2 147 483 647	-567
1205
DECIMAL
NUMERIC	Вещественное число,
в скобках указывается максимальная
длина числа (включает символы слева и справа от десятичной запятой)
и количество знаков после запятой.
Можно использовать оба этих типа, они эквивалентны,
принимают значения в диапазоне -1038+1 до 1038-1.
DECIMAL(4,1)
 NUMERIC(6,3)	 
 
 
34.6
-3.294
DATE	Дата в формате ГГГГ-ММ-ДД 
26 июля 2020 года
3 января 2021 года	 
2020-07-26
2021-01-03
VARCHAR	Строка длиной не более 255 символов,
в скобках указывается максимальная
длина строки, которая может храниться в поле
VARCHAR(10)(рассматриваются однобайтовые кодировки,
для которых число в скобках соответствует максимальному
количеству символов в строке)	 
 

пример
описание
Рекомендации по выбору типов данных для полей таблицы.
•	Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип VARCHAR(25).
•	Для описания ключевого поля используйте описание INT PRIMARY KEY AUTO_INCREMENT. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).

очень сложно описано DECIMAL  NUMERIC
Проще говоря речь идет о десятичных дробях = в скобках указано (а, b), где:
a - это общая длина числа, без учета точки.
b = кол-во разрядов / или оно же =  кол-во цифр после запятой / или оно же = как округляем число
 DECIMAL  (4,1) = > 897, 1
пример DECIMAL  (3,1) => 34,0
пример NUMERIC (9,10) = > 12345688,0000000001

Создание таблицы
Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :
•	ключевые слова : CREATE TABLE
•	имя создаваемой таблицы;
•	открывающая круглая скобка «(»;
•	название поля и его описание, которое включает тип поля и другие необязательные характеристики;
•	запятая;
•	название поля и его описание;
•	...
•	закрывающая скобка «)».
Пример. Создадим таблицу genre следующей структуры:
Поле	Тип, описание
genre_id	INT PRIMARY KEY AUTO_INCREMENT
name_genre	VARCHAR(30)
Запрос:
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
Созданная таблица - пустая.
Рекомендации по записи SQL запроса
•	Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово). 
•	Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.
•	Имена таблиц и полей - строчными (маленькими) буквами.
•	SQL-запрос можно писать на нескольких строках.
•	В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).

В таблицу, состоящую из двух столбцов добавим новую строку, при этом в поле1 заносится значение1,  в поле2 - значение2.
INSERT INTO таблица(поле1, поле2) (INTO можно пропустить).
VALUES (значение1, значение2);

При составлении списка полей и списка значений необходимо учитывать следующее:
1.	количество полей и количество значений в списках должны совпадать;
2.	должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;
3.	 типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция - недопустима);
4.	новые значения нельзя добавлять в поля, описанные как PRIMARY KEY AUTO_INCREMENT;
5.	рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (NULL).

Чтобы увидеть как именно выглядит таблица (отобрать все данные из неё), можно добавить SQL запрос, который выберет все записи из таблицы:
SELECT * FROM название таблицы;
Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 
•	ключевое слово SELECT ; 
•	список столбцов таблицы через запятую; 
•	ключевое слово FROM ; 
•	имя таблицы.
SELECT столбец1, столбец2 FROM название таблицы;

Выбрать определённые столбцы и переименовать их
Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые названия в результате выборки используется SQL запрос следующей структуры: 
•	ключевое слово SELECT ; 
•	имя столбца;
•	ключевое слово AS ; 
•	новое название столбца (можно русскими буквами), выводимое в результате запроса, но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, Количество_книг; 
•	запятая; 
•	имя столбца; 
•	.... •
•	ключевое слово FROM ; 
•	имя таблицы.
В одном запросе можно использовать и имена столбцов из таблицы, и новые названия.
Результатом является таблица, в которую включены все данные из указанных после SELECT столбцов исходной таблицы. Каждому столбцу в результате запроса присваивается новое имя, заданное после AS, или столбец получает имя столбца исходной таблицы, если AS отсутствует.
Пример
Выбрать все названия книг и их количества из таблицы book , для столбца title задать новое имя Название.
Запрос:
SELECT title AS Название, amount 
FROM book;

SELECT названия нужных столбцов через запятую,  			- создаст новый столбец из сложения других.
	Столбец1 +/-/* и другие действия Столбец2 AS название 
FROM book;

Выборка данных, вычисляемые столбцы, математические функции
В SQL реализовано множество  математических функций для работы с числовыми данными. В таблице приведены некоторые из них.
Функция	Описание	Пример
CEILING(x)	возвращает наименьшее целое число, большее или равное x
(округляет до целого числа в большую сторону)	CEILING(4.2)=5
CEILING(-5.8)=-5
ROUND(x, k)	округляет значение x до k знаков после запятой,
если k не указано – x округляется до целого	ROUND(4.361)=4
ROUND(5.86592,1)=5.9
FLOOR(x)	возвращает наибольшее целое число, меньшее или равное x
(округляет до  целого числа в меньшую сторону)	FLOOR(4.2)=4
FLOOR(-5.8)=-6
POWER(x, y)	возведение x в степень y	POWER(3,4)=81.0
SQRT(x)	квадратный корень из x	SQRT(4)=2.0
SQRT(2)=1.41...
DEGREES(x)	конвертирует значение x из радиан в градусы	DEGREES(3) = 171.8...
RADIANS(x)	конвертирует значение x из градусов в радианы	RADIANS(180)=3.14...
ABS(x)	модуль числа x	ABS(-1) = 1
ABS(1) = 1
PI()	pi = 3.1415926...	 
Пояснение.   Существуют разные способы округления чисел. В SQL реализовано математическое округление. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5,6,7,8 или 9.
Для каждой книги из таблицы book вычислим налог на добавленную стоимость (имя столбца tax) , который включен в цену и составляет k = 18%,  а также цену книги (price_tax) без него.
Эта формула НДС отвечает на вопрос "Какую сумму увеличили на 18%, чтобы получить текущее значение"
SELECT title, price, 
(price*18/100)/(1+18/100) AS tax, 
price/(1+18/100) AS price_tax 
FROM book;
Сумма налога и цена книги без налога – это деньги, поэтому количество знаков после запятой у этих чисел должно быть 2. Следовательно необходимо округлить полученные значения.
Запрос:
SELECT title, 
    price, 
    ROUND((price*18/100)/(1+18/100),2) AS tax, 
    ROUND(price/(1+18/100),2) AS price_tax 
FROM book;

Выборка данных, вычисляемые столбцы, логические функции
В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF():
IF(логическое_выражение, выражение_1, выражение_2)
Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1, в противном случае –  значение выражения_2. Все три параметра IF() являются обязательными.
Допускается использование вложенных функций, вместо выражения_1 или выражения_2 может стоять новая функция IF.
Пример 
Для каждой книги из таблицы book установим скидку следующим образом: если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.
SELECT title, amount, price, 
ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale 
FROM book;

Пример
Усложним вычисление скидки в зависимости от количества книг. Если количество книг меньше 4 – то скидка 50%, меньше 11 – 30%, в остальных случаях – 10%. И еще укажем какая именно скидка на каждую книгу.
Запрос:
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;

Выборка данных по условию
С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово WHERE и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.
Логическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.
Пример
Вывести название и цену тех книг, цены которых меньше 600 рублей.
Запрос:
SELECT title, price 
FROM book
WHERE price < 600;
 Пример
Вывести название, автора  и стоимость (цена умножить на количество) тех книг, стоимость которых больше 4000 рублей
Запрос:
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
В логическом выражении после WHERE нельзя использовать названия столбцов, присвоенные им с помощью AS,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос. Выборка данных, логические операции
 Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.
Приоритеты операций:
1.	круглые скобки
2.	умножение  (*),  деление (/)
3.	сложение  (+), вычитание (-)
4.	операторы сравнения (=, >, <, >=, <=, <>)
5.	NOT
6.	AND
7.	OR
Выборка данных, операторы BETWEEN, IN
 Логическое выражение после ключевого слова WHERE может включать операторы  BETWEEN и IN. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.
Оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.
Пример
Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.
Запрос:
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
Результат:
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
Этот запрос можно реализовать по-другому, результат будет точно такой же.
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
Оператор  IN  позволяет выбрать данные, соответствующие значениям из списка.
Пример
Выбрать названия и цены книг, написанных Булгаковым или Достоевским.
Запрос:
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
Этот запрос можно реализовать по-другому, результат будет точно такой же.
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
Выборка данных с сортировкой
При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию). 
Столбцы после ключевого слова ORDER BY можно задавать:
•	названием столбца;
•	номером столбца;
•	именем столбца (указанным после AS).
Пример
Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.
Запрос:
SELECT title, author, price
FROM book
ORDER BY title;
Аналогичный результат получится при использовании запроса:
SELECT title, author, price
FROM book
ORDER BY 1;
Пример
Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.
Запрос:
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
Важно! Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

Выборка данных, оператор LIKE
Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.
Символ-шаблон	Описание	Пример
%	Любая строка, содержащая ноль или более символов	SELECT * FROM book WHERE author LIKE '%М.%'
выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»
_ (подчеркивание)	Любой одиночный символ	SELECT * FROM book WHERE title LIKE 'Поэм_'
выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.
Пример 1
Вывести названия книг, начинающихся с буквы «Б».
Запрос:
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
Строчные и прописные буквы в строках эквивалентны. 
Пример 2
Вывести название книг, состоящих ровно из 5 букв.
Запрос:
SELECT title FROM book 
WHERE title LIKE "_ _ _ _ _"
Пример 3
Вывести книги, название которых длиннее 5 символов:
Запрос:
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
Результат:
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
| Капитанская дочка     |
+-----------------------+
Для того чтобы вывести названия, состоящие из любого количества символов послеLIKE можно использовать шаблон "%", с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку % заменяет любое количество символов, в том числе и нулевое.
Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:
•	 "_%" - сначала идет символ, а за ним любое количество символов;
•	"%_" - сначала идет любое количество символов, а затем обязательный символ;
•	"%_%" - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов.
•	Пример 4
•	Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.
•	 Запрос:
•	SELECT title FROM book 
•	WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
•	    OR title LIKE "и _%" /*отбирает слово И в начале названия */
•	    OR title LIKE "_% и" /*отбирает слово И в конце названия */
•	    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):
•	 в середине -  "_% и _%" - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный);
•	в начале - "и _%" - сначала идет "и", обязательный пробел и любое количество символов (один обязательный);
•	в конце - "_% и" - сначала идет любое количество символов, затем обязательный пробел и буква "и":
•	одно слово в названии - "и".
Вместо "_%" можно использовать эквивалентные шаблоны "%_" и "%_%" .
В качестве обязательного символа ( "_"), может быть и пробел, но, к сожалению, шаблоны для LIKE не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений (будут рассмотрены в уроке 3.5)
Пример 5
Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .
 Запрос:
SELECT title FROM book 
WHERE title NOT LIKE "% %";    
Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор NOT LIKE, который в данном случае отберет все названия, в которых нет пробелов.

Выбор уникальных элементов столбца
Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.
Пример
Выбрать различных авторов, книги которых хранятся в таблице book.
Запрос:
SELECT DISTINCT author
FROM book;
Результат:
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
Другой способ – использование оператора GROUP BY, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после GROUP BY .
С помощью GROUP BY можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании DISTINCT.
Выборка данных, групповые функции SUM и COUNT
При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.
Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
•	COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
•	COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.

ВАЖНО.
1.	Если столбец указан в SELECT  БЕЗ применения групповой функции, то он обязательно должен быть указан и вGROUP BY.Иначе получим ошибку.
2.	Между названием функции и скобкой НЕЛЬЗЯ СТАВИТЬ ПРОБЕЛ. Это особенность платформы.

Выборка данных, групповые функции MIN, MAX и AVG
К групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.
Пример
Вывести минимальную цену книги каждого автора
Запрос:
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
Выборка данных c вычислением, групповые функции
В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.
Пример
Вывести суммарную стоимость книг каждого автора.
Запрос:
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
Вычисления по таблице целиком
Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.
Пример
Посчитать количество экземпляров книг на складе.
Запрос:
SELECT SUM(amount) AS Количество
FROM book;
Выборка данных по условию, групповые функции
В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.
Пример
Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.
Запрос:
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
Выборка данных по условию, групповые функции, WHERE и HAVING
Для этого урока теоретическая часть подготовлена Alexandra Klinnikova, спасибо большое!
WHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:
1.	FROM
2.	WHERE
3.	GROUP BY
4.	HAVING
5.	SELECT
6.	ORDER BY
Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),  из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING. Потом формируются данные результирующей выборки, как это указано после SELECT ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после ORDER BY.
Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему неизвестно, какое там выражение написано.
Пример
Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
Другим способом решения примера является запрос:
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
Не смотря на то что результат будет одинаковым, так делать не рекомендуется. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает.
Вложенный запрос, возвращающий одно значение
Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.
Пример
Вывести информацию о самых дешевых книгах, хранящихся на складе.
Для реализации этого запроса нам необходимо получить минимальную цену из столбца price таблицы book, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.
Запрос:
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
Результат:
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.
ABS – абсолютные значения (модуль), например есть ли отличия и в сторону плюса, и в сторону минуса.
Вложенный запрос, оператор IN
Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором IN.
WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
Оператор IN определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после WHERE получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.
Пример
Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.
Запрос:
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
Результат:
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
Вложенный запрос отбирает двух авторов (Достоевского и Есенина). А в основном запросе для каждой записи таблицы book  проверяется, входит ли автор книги в отобранный список, если входит - информация о книге включается в запрос.
Вложенный запрос, операторы ANY и ALL
 Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).
Операторы ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.
При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY:
•	amount > ANY (10, 12) эквивалентно amount > 10
•	amount < ANY (10, 12) эквивалентно amount < 12
•	amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)
•	amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12
При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:
•	amount > ALL (10, 12) эквивалентно amount > 12
•	amount < ALL (10, 12) эквивалентно amount < 10
•	amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
•	amount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12
Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.
Пример
Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.
Запрос:
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
Результат:
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
Пояснение
1. Вложенный запрос
SELECT AVG(amount) 
        FROM book 
        GROUP BY author
отбирает следующие записи:
+-------------+
| AVG(amount) |
+-------------+
| 4.0000      |
| 7.6667      |
| 15.0000     |
+-------------+
2. Условие отбора в основном запросе
amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      )
можно переписать (если заменить вложенный запрос списком отобранных значений):
amount < ALL ( 4.0000, 7.6667, 15.0000)
что в соответствии с определением ALL, это значит, что подходят все amount меньшие 4.000.
Таким образом, наш запрос отобрал все книги книги Мастер и Маргарита и Братья Карамазовы, количество которых равно 3. 
Вложенный запрос после SELECT
Вложенный запрос может располагаться после ключевого слова SELECT. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.
Пример
Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.
Запрос:
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
Результат:
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца Среднее_количество в результирующей таблице запроса. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.
Добавление записей из другой таблицы
С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список VALUES), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела VALUES записывается запрос на выборку, начинающийся с SELECT.  В нем можно использовать WHERE, GROUP BY, ORDER BY.
Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
1.	количество полей в таблице и количество полей в запросе должны совпадать;
2.	должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
3.	 типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция – недопустима).
Пример
Занести все книги из таблицы supply в таблицу book.
Запрос:
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
Результат:
Affected rows: 4
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 9
С помощью этого запроса в таблицу book включены все книги из supply, даже те, которые в book уже есть («Белая гвардия» и «Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это нежелательная ситуация. Устранить эту проблему можно с помощью вложенных запросов, которые будут рассмотрены в следующем шаге.
Запросы на обновление
Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.
Изменение записей в таблице реализуется с помощью запроса UPDATE. Простейший запрос на  обновление выглядит так:
UPDATE таблица SET поле = выражение
где 
таблица – имя таблицы, в которой будут проводиться изменения;
поле – поле таблицы, в которое будет внесено изменение;
выражение – выражение,  значение которого будет занесено в поле.
Пример
Уменьшить на 30% цену книг в таблице book.
Запрос:
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
Результат:
Affected rows: 5
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово WHERE, после которого указывается условие отбора строк для изменения.
Пример
Уменьшить на 30% цену тех книг в таблице book, количество которых меньше 5.
Запрос:
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
Результат:
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
В этом запросе обновляется только 2 записи (цена книг «Мастер и Маргарита» и «Братья Карамазовы»).
Запросы на обновление нескольких столбцов
Запросом UPDATE можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
Запросы на обновление нескольких таблиц 
В запросах на обновление можно использовать несколько таблиц, но тогда
•	для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
•	все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
•	в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.
Пример
Если в таблице supply  есть те же книги, что и в таблице book, добавлять эти книги в таблицу book не имеет смысла. Необходимо увеличить их количество на значение столбца amountтаблицы supply.
Запрос:
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
Результат:
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в supply имеет ту же цену, и «Идиот», но цена этой книги в таблицах book и supply отличается. Для этой книги нужно пересчитать цену. (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

Запросы на удаление
Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:
DELETE FROM таблица;
Этот запрос удаляет все записи из указанной после FROM таблицы.
Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова WHERE:
DELETE FROM таблица
WHERE условие;

Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:
CREATE TABLE имя_таблицы AS
SELECT ...
Пример
Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое количество экземпляров 5.
Запрос:
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
Результат:
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 5      |
| Достоевский Ф.М. | Братья Карамазовы  | 5      |
+------------------+--------------------+--------+
При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.
Пример
Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.
Запрос:
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
Результат:
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
Оператор LIMIT
Для ограничения вывода записей в SQL используется оператор LIMIT , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY.
Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 
Пример
Вывести информацию о первой  командировке из таблицы trip. "Первой" считать командировку с самой ранней датой начала.
Запрос:
SELECT *
FROM trip
ORDER BY  date_first
LIMIT 1;
Результат:
+---------+--------------+--------+----------+------------+------------+
| trip_id | name         | city   | per_diem | date_first | date_last  |
+---------+--------------+--------+----------+------------+------------+
| 1       | Баранов П.Е. | Москва | 700.00   | 2020-01-12 | 2020-01-17 |
+---------+--------------+--------+----------+------------+------------+
Важно. Оператор LIMIT нужно использовать очень осторожно. Например, если бы в таблице trip было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.
Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2. Например,
DATEDIFF('2020-04-01', '2020-03-28')=4

DATEDIFF('2020-05-09','2020-05-01')=8

DATEDIFF(date_last, date_first)
Увеличьте разницу на 1, чтобы включить первый день командировки.
Для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).
Например, MONTH('2020-04-12') = 4.
Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)
1.	Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
2.	Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после GROUP BYможно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

1. В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020
2. Количество дней командировки вычисляется как разница между датами последнего и первого дня командировки плюс 1.
Использование временного имени таблицы (алиаса)
Чтобы не писать название таблицы каждый раз, удобно использовать алиасы.
Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова AS(шаг).  Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более. Псевдонимы помогают сделать запрос чище и читабельнее.
Для присваивания псевдонима существует 2 варианта: 
•	с использованием ключевого слова AS 
FROM fine AS f, traffic_violation AS tv
•	а так же и без него
FROM fine f, traffic_violation tv
После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. Например:
WHERE f.violation = tv.violation
Пример
Для тех, кто уже оплатил штраф, вывести информацию о том, изменялась ли стандартная сумма штрафа.
Запрос:
SELECT  f.name, f.number_plate, f.violation, 
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description               
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
Результат: 
+---------------+--------------+----------------------------------+--------------------------+
| name          | number_plate | violation                        | description              |
+---------------+--------------+----------------------------------+--------------------------+
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | Уменьшенная сумма штрафа |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | Стандартная сумма штрафа |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | Стандартная сумма штрафа |
+---------------+--------------+----------------------------------+--------------------------+
Сравнение значения столбца с пустым значением осуществляется с помощью оператора IS NULL.
Группировка данных по нескольким столбцам
В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
1. Сначала записи таблицы  fine разделяются на группы. В каждую группу включаются строки, у которых равны значения в столбцах name, number_plate и violation  соответственно. Получается 6 групп. 
 
2. Затем вычисляется функция count(*), которая определяет количество записей в каждой группе. Получается, что к первым двум группам относятся по две записи, ко всем остальным - по одной.
 
Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из SELECT.

Связь «один ко многим»
Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы.
Пример: Человек может иметь как один, так и несколько паспортов. Но каждый из этих паспортов будет указывать на этого конкретного человека. Паспорт внутри себя не может содержать информацию о двух людях (две фотки, например). Обычно один человек = один паспорт, но вполне возможно ситуация с наличием нескольких паспортов.
Этапы реализации связи «один ко многим» на следующем примере:
Один автор может написать несколько книг, а одна книга написана только одним автором. Для каждой книги известны ее количество и цена.
1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе:
 
2. Обе таблицы должны содержать первичный ключ, в таблице  bookон уже есть,  в таблицу authorдобавим ключ author_id:
 
3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id). Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы:
 

Связь «многие ко многим»
Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой.
Этапы реализации связи «многие ко многим»  на следующем примере:
Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами. Для каждой книги известны ее количество и цена.
1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе:
 
2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице book он уже есть, поэтому достаточно включить первичный ключ author_id в таблицу author:
 
3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. Каждый из этих столбцов является внешним ключом (FOREIGN KEY)  и связан с ключевым столбцом каждой таблицы. Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы.
 
4. Дальше необходимо определиться с первичным ключом таблицы-связки. Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, например, если мы будем продавать книги покупателям (один человек может купить несколько книг, а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, например, дату продажи,  также в таблицу-связку добавляют первичный ключ. Мы воспользуемся вторым способом:
 
Создание таблицы с внешними ключами
При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что :
•	каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (в наших примерах это INT);
•	необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:
FOREIGN KEY (связанное_поле_зависимой_таблицы)  
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
По умолчанию любой столбец, кроме ключевого, может содержать значение NULL. При создании таблицы это можно переопределить,  используя  ограничение NOT NULL для этого столбца:
CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);
 В созданной таблице в столбец_1 не может содержать пустое значение, а столбец_2 - может.
Для внешних ключей рекомендуется устанавливать ограничение NOT NULL (если это совместимо с другими опциями, которые будут рассмотрены в следующем шаге).
 Пример
Создать таблицу book следующей структуры:
Поле	Тип, описание	Связи
book_id	INT PRIMARY KEY AUTO_INCREMENT	 
title	VARCHAR(50)	 
author_id	INT 	внешний ключ:
главная таблица author,
связанный столбец author.author_id,
пустое значение не допускается
price	DECIMAL(8, 2)	 
amount	INT	 
Запрос:
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) 
);
Действия при удалении записи главной таблицы
С помощью выражения ON DELETE можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:
•	CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
•	SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
•	SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца.
•	RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.
Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение.
Пример
Будем считать, что при удалении автора из таблицы author, необходимо удалить все записи о книгах из таблицы book, написанные этим автором. Данное действие необходимо прописать при создании таблицы.
Запрос:
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
);
Соединение INNER JOIN
Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
Результат запроса формируется так:
•	каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
•	для полученной «соединённой» строки проверяется условие соединения;
•	если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;
Пример
Вывести название книг и их авторов.
Запрос:
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
Поскольку поля author_id в таблицах book и author называются одинаково, необходимо в запросах указывать полную ссылку на них (book.author_id и author.author_id).
Результат:
+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
В данном запросе осуществляется соединение главной таблицы author и зависимой таблицы book по ключевому столбцу author.author_id и внешнему ключу book.author_id. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы book дополняются фамилией и инициалами авторов из таблицы author.
реализуя INNER JOIN можно опустить INNER, т.к он используется по дефолту.
Так же, если мы имеем таблицы где PR и FK(в другой таблице) имеют одно название, для соединения можно заменить ON book.genre_id = genre.genre_id на USING(genre_id) - записи эквивалентны
Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
Результат запроса формируется так:
1.	в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием;
2.	затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.
Пример
Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.
Запрос:
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
Результат:
+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
Так как в таблице book нет книг Лермонтова, напротив этой фамилии стоит Null.
Перекрестное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения CROSS JOIN (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
или
SELECT
 ...
FROM
    таблица_1, таблица_2
...
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.
Например, запрос:
SELECT name_author, name_genre
FROM 
    author, genre;
каждому автору из таблицы author поставит в соответствие все возможные жанры из таблицы genre:
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
Запросы на выборку из нескольких таблиц
Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение INNER JOIN, поэтому в примерах будем использовать его.
Пусть таблицы связаны между собой следующим образом:
 
тогда запрос на выборку для этих таблиц будет иметь вид:
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
Если же таблицы связаны так:
 
то запрос на выборку выглядит следующим образом:
SELECT
 ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: first → third → second.
Пример
Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500  до 700 рублей  включительно.
Запрос:
SELECT title, name_author, name_genre, price, amount
FROM
    author 
    INNER JOIN  book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
Результат:
+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).
Пример
Вывести авторов, общее количество книг которых на складе максимально.
Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.
Шаг 1. Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id.
Запрос:
SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id
Результат:
+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после FROM. Затем уже находить максимум по столбцу sum_amount.
Запрос:  
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
Результат:
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
Шаг 3. Выведем фамилию автора и общее количество книг для него.
Запрос:  
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
Результат:
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
Шаг 4.  Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.
 Запрос:  
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
Результат:
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
Вложенные запросы в операторах соединения
Вложенные запросы могут использоваться в операторах соединения JOIN.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
Вложенный запрос может стоять как справа, так и слева от оператора JOIN. Допускается использование двух запросов в операторах соединения.
Пример
Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.
Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице book.
book_id	title	author_id	genre_id	price	amount
8	Лирика	4	2	518.9910	10
А также добавлены новые записи:
book_id	title	author_id	genre_id	price	amount
9	Герой нашего времени	5	3	570.59	2
10	Доктор Живаго	4	3	740.50	5
Рассмотрим реализацию этого запроса по шагам.
Шаг 1. Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.
Запрос:
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
Результат:
+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
Кажется, что, уже используя этот запрос, можно получить id самого популярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно sum_amount.
Шаг 2. Используя запрос с предыдущего шага, найдем id самых популярных жанров.
Запрос:
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
  
Результат:
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
Шаг 3. Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре.
Запрос:
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
Важно!
1.	Обратите внимание, что в группировку включен столбецgenre_id, который используется в HAVING. Это связано с тем, что в HAVING можно использовать либо столбцы, перечисленные в GROUP BY, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца genre_idне влияет на группировку, так как между названием жанра и его id - взаимно-однозначное соответствие.
2.	Название столбца genre_id задается с указанием имени таблицы (genre.genre_id), так как этот столбец входит в структуру двух таблиц book и genre.  Для этого запроса можно было бы указать и book.genre_id, так как эти таблицы связаны внутренним соединением INNER JOIN и имеют одинаковые значения в полях genre.genre_id и book.genre_id.
Результат:
+------------------+------------+
| name_author      | name_genre |
+------------------+------------+
| Достоевский Ф.М. | Роман      |
| Булгаков М.А.    | Роман      |
| Пастернак Б.Л.   | Поэзия     |
| Есенин С.А.      | Поэзия     |
 
Операция соединение, использование USING()
При описании соединения таблиц с помощью JOIN в некоторых случаях вместо ON и следующего за ним условия можно использовать оператор USING().
USING позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение USING для реализации операции JOIN. 
При этом после SELECT, при использовании столбцов из USING(), необязательно указывать, из какой именно таблицы берется столбец.
Пример
Вывести название книг, фамилии и id их авторов.
Запрос:
Вариант с ON
SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
Вариант с USING
SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
Результат (одинаковый для обоих запросов):
+-----------------------+------------------+-----------+
| title                 | name_author      | author_id |
+-----------------------+------------------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 1         |
| Белая гвардия         | Булгаков М.А.    | 1         |
| Идиот                 | Достоевский Ф.М. | 2         |
| Братья Карамазовы     | Достоевский Ф.М. | 2         |
| Игрок                 | Достоевский Ф.М. | 2         |
| Стихотворения и поэмы | Есенин С.А.      | 3         |
| Черный человек        | Есенин С.А.      | 3         |
| Лирика                | Пастернак Б.Л.   | 4         |
+-----------------------+------------------+-----------+
Запись условия соединения с ON является более общим случаем, так как
•	позволяет задавать соединение не только по одноименным полям;
•	позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.
Пример
В таблице supply занесена информация о книгах, поступивших на склад.
supply_id	title	author	price	amount
1	Доктор Живаго	Пастернак Б.Л.	618.99	3
2	Черный человек 	Есенин С.А.	570.20	6
3	Евгений Онегин	Пушкин А.С.	440.80	5
4	Идиот	Достоевский Ф.М.	360.80	3
Если в таблицах supply  и book есть одинаковые книги,  вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковым названием.
Важно. В данном примере для соединения book и supply использовать USING нельзя, так как: 
•	в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author, столбец name_author),  а в таблице supply фамилии занесены в столбец author;
•	для однозначной идентификации книги нужно указать, что совпадают не только названия, но и авторы книг.
Запрос:
SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
Результат:
+----------------+------------------+
| title          | name_author      |
+----------------+------------------+
| Идиот          | Достоевский Ф.М. |
| Черный человек | Есенин С.А.      |
Запросы на обновление, связанные таблицы
В запросах на обновление можно использовать связанные таблицы:
UPDATE таблица_1
     ... JOIN таблица_2
     ON выражение
     ...
SET ...   
WHERE ...;
При этом исправлять данные можно во всех используемых в запросе таблицах.
Пример
Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (supply), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.
Этот запрос должен отобрать строки из таблиц bookи supply такие, что у них совпадают и автор, и название книги. Но в таблице supply фамилия автора записана не числом (id), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу author,  которая связана с bookпо столбцу author_id.  И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц book, authorи supply. 
Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор AND. Например, для следующих таблиц логическую связь по названию и автору:
 
условие соединения можно записать в виде:
book INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                          and supply.author = author.name_author
Запрос:
UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price = supply.price;

SELECT * FROM book;

SELECT * FROM supply;
Результат:
Affected rows: 4

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 8

Query result:
+-----------+-----------------------+------------------+--------+--------+
| supply_id | title                 | author           | price  | amount |
+-----------+-----------------------+------------------+--------+--------+
| 1         | Доктор Живаго         | Пастернак Б.Л.   | 380.80 | 4      |
| 2         | Черный человек        | Есенин С.А.      | 570.20 | 0      |
| 3         | Белая гвардия         | Булгаков М.А.    | 540.50 | 0      |
| 4         | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
| 5         | Стихотворения и поэмы | Лермонтов М.Ю.   | 255.90 | 4      |
| 6         | Остров сокровищ       | Стивенсон Р.Л.   | 599.99 | 5      |
+-----------+-----------------------+------------------+--------+--------+
Affected rows: 6
Под нужное нам условие подходят две книги «Белая гвардия» Булгакова и «Черный человек» Есенина. В таблице book их количество увеличилось, а в таблице supply - обнулилось.
Запрос на добавление, связанные таблицы
Следующий шаг - добавить новые записи о книгах, которые есть в таблице supply и нет в таблице book. (В таблицах supply и book сохранены изменения предыдущих шагов). Поскольку в таблице supply не указан жанр книги, оставить его пока пустым (занести значение Null).
Пример
Прежде всего необходимо сформировать запрос с полями, которые соответствуют полям таблицы book, так как использовать только таблицу supply нельзя - в ней вместо кода автора стоит его фамилия. 
Запрос:
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author;
Результат:
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Черный человек        | 3         | 570.20 | 0      |
| Белая гвардия         | 1         | 540.50 | 0      |
| Идиот                 | 2         | 360.80 | 0      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
Далее необходимо отобрать только новые книги из таблицы supply. Как видно из таблицы с результатами запроса, в тех записях, которые нужно добавить, значения столбца amount не равны 0 (количество уже учтенных книг обнулены предыдущим запросом). Добавим это условие в запрос.
Запрос:
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;
Результат:
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
Запрос на обновление, вложенные запросы
После того, как новые книги добавлены в таблицу book, нужно указать к какому жанру они относятся. Для этого используется запрос на обновление, в котором можно указать значения столбцов из других таблиц, либо использовать вложенные запросы для получения этих значений.
Пример
Задать для книги Пастернака «Доктор Живаго»  жанр «Роман».
Если мы знаем код этой книги в таблице book (в нашем случае это 9) и код жанра «Роман» в таблице genre (это 1), запрос будет очень простым.
Запрос:
UPDATE book
SET genre_id = 1
WHERE book_id = 9;

SELECT * FROM book;
Результат:
Affected rows: 1

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | NULL     | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | NULL     | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Более сложным будет запрос, если известно только название жанра (результат будет точно таким же):
Запрос:
UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Роман'
      )
WHERE book_id = 9;

SELECT * FROM book;
Каскадное удаление записей связанных таблиц
При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия , выполняемые при удалении связанной строки из главной таблицы.
В частности, ON DELETE CASCADE автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
В таблице book эта опция установлена для поля author_id.
Пример
Удалим из таблицы author всех авторов, фамилия которых начинается на «Д», а из таблицы book  - все книги этих авторов.
Запрос:
DELETE FROM author
WHERE name_author LIKE "Д%";

SELECT * FROM author;

SELECT * FROM book;
Результат:
Affected rows: 1

Query result:
+-----------+----------------+
| author_id | name_author    |
+-----------+----------------+
| 1         | Булгаков М.А.  |
| 3         | Есенин С.А.    |
| 4         | Пастернак Б.Л. |
| 5         | Лермонтов М.Ю. |
| 6         | Стивенсон Р.Л. |
+-----------+----------------+
Affected rows: 5

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Одним запросом удаляются связанные записи из главной и зависимой таблицы. В нашем случае удалился автор Достоевский и все его книги.
Удаление записей главной таблицы с сохранением записей в зависимой
При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.
Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL. (При этом в столбце внешнего ключа должно быть допустимо значение NULL)
В таблице book эта опция установлена на поле genre_id.
Пример
Удалим из таблицы genre все  жанры, название которых заканчиваются на «я» , а в таблице book  -  для этих жанров установим значение Null.
Запрос:
DELETE FROM genre
WHERE name_genre LIKE "%я";

SELECT * FROM genre;

SELECT * FROM book;
Результат:
Affected rows: 2

Query result:
+----------+------------+
| genre_id | name_genre |
+----------+------------+
| 1        | Роман      |
+----------+------------+
Affected rows: 1

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | Null     | 650.00 | 15     |
| 7       | Черный человек        | 3         | Null     | 570.20 | 12     |
| 8       | Лирика                | 4         | Null     | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | Null     | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | Null     | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 11
В нашем случае удалились жанры «Поэзия» и «Приключения».
Удаление записей, использование связанных таблиц
При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:
DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...
Пример
Удалить всех авторов из таблицы author, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы book удалить все книги этих авторов.
Запрос:
DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
WHERE book.amount < 3;

SELECT * FROM author;

SELECT * FROM book;
Результат:
Affected rows: 1

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 5         | Лермонтов М.Ю.   |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Affected rows: 5

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Книги из таблицы book будут удалены автоматически, так как для столбца author_id из таблицы book установлено каскадное удаление записей.
Оператор UNION
Оператор UNION используется для объединения двух и более SQL запросов, его синтаксис:
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
или
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
Важно отметить, что каждый из SELECT должен иметь в своем запросе одинаковое количество столбцов и  совместимые типы возвращаемых данных. Каждый запрос может включать разделы WHERE, GROUP BY и пр.
В результате выполнения этой конструкции будет выведена таблица, имена столбцов которой соответствуют именам столбцов в первом запросе. А в таблице результата сначала отображаются записи-результаты первого запроса, а затем второго. Если указано ключевое слово ALL, то в результат включаются все записи запросов, в противном случае - различные.
Пример
Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.
На этом примере рассмотрим разницу между UNION и UNION ALL.
С UNION клиенты будут выведены без повторений:
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Абрамова Катя   |
| Яковлева Галина |
| Семенонов Иван  |
+-----------------+
Affected rows: 4
C UNION ALL будут выведены клиенты с повторением (для тех, кто заказывал книги в обоих годах, а также несколько раз в одном году)
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION ALL
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Абрамова Катя   |
| Яковлева Галина |
| Яковлева Галина |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Семенонов Иван  |
+-----------------+
Affected rows: 14
Пример
Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию отсортировать по  client_id.
Запрос:
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"  
Результат:
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
+--------+-----------+---------+--------------+--------+--------+
В результат включены сначала записи архивной таблицы, а затем информация об оплаченных заказах  текущего года. Для того, чтобы изменить порядок следования записей в объединенном запросе, можно использовать сортировку по всем объединенным записям. В этом случае ключевые слова ORDER BY указываются после последнего запроса: 
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
ORDER BY client_id
Результат:
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
+--------+-----------+---------+--------------+--------+--------+
Случайные значение.
Для выбора случайных вопросов можно отсортировать вопросы в случайном порядке:
ORDER BY RAND()


1. Чтобы выделить крайние левые n символов из строки используется функция LEFT(строка, n):
LEFT("abcde", 3) -> "abc"
2. Соединение строк осуществляется с помощью функции CONCAT(строка_1, строка_2):
CONCAT("ab","cd") -> "abcd"
Изменение структуры таблицы
Для изменения структуры таблицы используется оператор ALTER TABLE. С его помощью можно вставить новый столбец, удалить существующий, переименовать столбец и пр.
Для вставки нового столбца используется SQL запросы:
ALTER TABLE таблица ADD имя_столбца тип; - вставляет столбец после последнего
ALTER TABLE таблица ADD имя_столбца тип FIRST; - вставляет столбец перед первым
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1; - вставляет столбец после укзанного столбца
Для удаления столбца используется SQL запросы:
ALTER TABLE таблица DROP COLUMN имя_столбца; - удаляет столбец с заданным именем
ALTER TABLE таблица DROP имя_столбца; - ключевое слово COLUMN не обязательно указывать
ALTER TABLE таблица DROP имя_столбца,
                    DROP имя_столбца_1; - удаляет два столбца
Для переименования столбца используется  запрос (тип данных указывать обязательно):
ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;
Для изменения типа  столбца используется запрос (два раза указывать имя столбца обязательно): 
ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;
Переменные
 Переменные задаются с помощью ключевого слова SET,  перед именем указывается символ @. Например, создадим переменную @row_num и присвоим ей значение 1:
SET @row_num := 1;
Теперь эту переменную можно использовать в запросах,  кроме того в запросах можно изменить ее значение. 
Пример
Пронумеруем записи в таблице applicant_order.
Запрос:
SET @row_num := 0;

SELECT *, (@row_num := @row_num + 1) AS str_num
FROM  applicant_order;
Выражение  @row_num := @row_num + 1 означает, что для каждой записи, выводимой в запрос, значение переменной @row_num увеличивается на 1. В результате получается нумерация строк запроса.
Пример
Создадим нумерацию, которая начинается заново для каждой образовательной программы. Для этого можно использовать алгоритм, в котором в переменную @row_num заносится 1, если id программы в предыдущей записи не равен id программы в текущей:
•	объявить переменную @num_pr, задать ей начальное значение;
•	запомнить id образовательной программы для текущей записи в переменной @num_pr;
•	для следующей записи сравнить значение переменной @num_pr с id образовательной программы;
•	если они равны, то продолжить нумерацию @row_num := @row_num + 1;
•	в противном случае начать нумерацию снова, для этого установить @row_num := 1.
Запрос:
SET @num_pr := 0;
SET @row_num := 1;

SELECT *, 
     if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1) AS str_num,
     @num_pr := program_id AS add_var 
from applicant_order;
Результат:
+------------+-------------+------+---------+---------+
| program_id | enrollee_id | itog | str_num | add_var |
+------------+-------------+------+---------+---------+
| 1          | 3           | 235  | 1       | 1       |
| 1          | 2           | 226  | 2       | 1       |
| 1          | 1           | 219  | 3       | 1       |
| 2          | 6           | 276  | 1       | 2       |
| 2          | 3           | 235  | 2       | 2       |
| 2          | 2           | 226  | 3       | 2       |
| 3          | 6           | 270  | 1       | 3       |
| 3          | 4           | 239  | 2       | 3       |
| 3          | 5           | 200  | 3       | 3       |
| 4          | 6           | 270  | 1       | 4       |
| 4          | 3           | 247  | 2       | 4       |
| 4          | 5           | 200  | 3       | 4       |
+------------+-------------+------+---------+---------+
Выборка данных по нескольким условиям, оператор CASE
С помощью оператора CASE можно в зависимости от нескольких условий получить один из нескольких результатов.
Оператор CASE записывается в виде:
CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END  
Раздел ELSE является необязательным.
Выполняется оператор CASE так:
•	вычисляется логическое_выражение_1, если оно истинно, то результатом оператора является выражение_1, если ложно - выполнение оператора продолжается;
•	вычисляется логическое_выражение_2, если оно истинно, то результатом оператора является выражение_2, если ложно - выполнение оператора продолжается;
•	если все логические выражения оказались ложными, то результат оператора - выражение_else
CASE можно использовать в  SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING - всюду, где можно использовать выражения.
Пример
Отнести каждого студента к группе,  в зависимости от пройденных заданий:
Интервал	Группа
от 0 до 10	I
от 11 до 15	II
от 16 до 27	III
больше 27	IV
Пройденными считаются задания с хотя бы одним верным ответом. В таблице step_student сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.
 Фрагмент логической схемы базы данных:
 
Шаг 1. Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать  правильные решения несколько раз.
Запрос:
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
Результат:
Query result:
+--------------+---------+
| student_name | step_id |
+--------------+---------+
| student_52   | 10      |
| student_11   | 10      |
| student_19   | 10      |
| student_4    | 10      |
| student_5    | 10      |
| student_53   | 10      |
| student_39   | 10      |
| student_32   | 10      |
| student_61   | 10      |
| student_43   | 10      |
| student_13   | 10      |
| student_57   | 10      |
             ...
+--------------+---------+

Affected rows: 1126.
 Шаг 2. Посчитаем, сколько шагов прошел каждый студент.
Запрос:
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
Результат:
+--------------+------+
| student_name | rate |
+--------------+------+
| student_29   | 8    |
| student_47   | 8    |
| student_16   | 9    |
| student_5    | 9    |
| student_63   | 9    |
| student_33   | 10   |
| student_17   | 10   |
| student_64   | 10   |
            ...
+--------------+------+
Affected rows: 64
Шаг 3. Отнести каждого студента к группе в зависимости от пройденных шагов.
 Запрос:
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
Результат:
Query result:
+--------------+------+--------+
| student_name | rate | Группа |
+--------------+------+--------+
| student_29   | 8    | I      |
| student_47   | 8    | I      |
| student_16   | 9    | I      |
| student_5    | 9    | I      |
| student_63   | 9    | I      |
| student_33   | 10   | I      |
| student_17   | 10   | I      |
| student_64   | 10   | I      |
| student_58   | 10   | I      |
| student_38   | 10   | I      |
| student_12   | 11   | II     |
| student_10   | 11   | II     |
              ...
+--------------+------+--------+
Affected rows: 64
Табличные выражения, оператор WITH
Своими словами – если нам нужны несколько разных показателей из одной таблицы, мы можем каждый показатель для краткости обозвать и дальше использовать краткие названия.
Табличное выражение определяется с помощью оператора WITH и является частью запроса. Его синтаксис: 
WITH имя_выражения (имя_1, имя_2,...)
  AS
    (
     SELECT столбец_1, столбец_2,
     FROM 
       ... 
     )
SELECT ...
   FROM имя_выражения
   ...
В табличном выражении определяется запрос, результат которого нужно использовать в основной части запроса после SELECT. При этом основной запрос может обратиться к столбцам результата табличного выражения через имена, заданные в заголовке WITH. При этом количество имен должно совпадать с количеством результирующих столбцов табличного выражения.
В одном запросе может быть несколько табличных выражений. При этом в каждом табличном выражении можно использовать все предшествующие ему табличные выражения.
В табличном выражении необязательно давать имена столбцам результата. В этом случае в основном запросе можно использовать имена столбцов, указанных после SELECT в табличном выражении. При наличии одинаковых имен в нескольких табличных выражениях необходимо использовать полное имя столбца (имя табличного выражения, точка, имя столбца).
Пример
Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений. Столбцы результата назвать Шаг и Успешность, процент успешных решений округлить до целого.
Важно. Только для этого задания для одного из шагов установлено, что все ответы пользователей - неверные.
Фрагмент логической схемы базы данных:
 
Шаг 1. Создадим запрос, который для каждого шага вычисляет количество правильных ответов, данных пользователями.
Запрос:
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "correct"
GROUP BY step_name;
Результат:
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 66       |
| Выборка отдельных столбцов                                    | 65       |
| Выборка отдельных столбцов и присвоение им новых имен         | 66       |
| Выборка данных с созданием вычисляемого столбца               | 64       |
| Выборка данных, вычисляемые столбцы, математические функции   | 66       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 31
Шаг 2. Создадим запрос, который для каждого шага вычисляет количество неверных ответов, данных пользователями.
Запрос:
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "wrong"
GROUP BY step_name;
Результат:
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 10       |
| Выборка отдельных столбцов                                    | 20       |
| Выборка отдельных столбцов и присвоение им новых имен         | 13       |
| Выборка данных с созданием вычисляемого столбца               | 23       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 30
Шаг 3. Создадим запрос с табличными выражениями, который вычисляет процент верных решений. Запрос первого шага включим как табличное выражение с именем get_count_correct, запрос второго шага - как табличное выражение get_count_wrong.
Запрос:
WITH get_count_correct (st_n_c, count_correct) 
  AS (
      SELECT step_name, count(*)
      FROM 
          step 
          INNER JOIN step_student USING (step_id)
      WHERE result = "correct"
      GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг, 
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    INNER JOIN get_count_wrong ON st_n_c = st_n_w
Результат:
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 30
Шаг 4. Обратите внимание, что всего вопросов в таблице 32,  но запрос первого шага вывел общее количество вопросов - 31, а запрос второго шага - 30. Это значит, что на одно задание все пользователи дали неверный ответ, а на два -  все пользователи дали верный ответ. 
Следовательно, нужно вместо внутреннего соединения INNER JOIN применить полное внешнее соединение FULL JOIN. Это соединение в MySQL не поддерживается, его можно реализовать запросами с LEFT и RIGHT JOIN, соединенных оператором UNION:
SELECT ...
   FROM таблица_1 LEFT JOIN таблица_2 ON ...
...
UNION
SELECT ...
   FROM таблица_1 RIGHT JOIN таблица_2 ON ...
...
Запрос шага 4:
WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2 ;
Результат:
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | None       |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | None       |
| Построение логической схемы базы данных                                  | None       |
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |     
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 32
Процент успешных попыток для тех шагов, которые не имеют неверных ответов  или не имеют верных - Null, а должно быть 100% и 0%  соответственно. Это произошло из-за того, что при внешнем соединении, вместо отсутствующего значения в результат подставляется Null.
Оконные функции, оператор OVER, ORDER BY
Оконные функции позволяют получить некоторую дополнительную информацию о выборке данных .  С помощью оконных функций можно реализовать вычисления для набора строк, некоторым образом связанных с текущей строкой. При этом использование оконной функции не группирует несколько строк в одну, а сохраняет все строки запроса. Синтаксис оконных функций:
название_функции(выражение) 
  OVER (
        PARTITION BY столбец_1, столбец_2, ... - это окно
        ORDER BY ... - сортировка 
        ROWS BETWEEN - границы окна
          ...
  )
Причем все разделы OVER являются не обязательными, но обязательно нужно указать либо окно, либо сортировку. На данном шаге рассмотрим самый простой синтаксис оконного выражения:
название_функции(выражение) 
  OVER (
        ORDER BY ...
  )
Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы (здесь окно - вся таблица). В качестве функций можно использовать:
ROW_NUMBER() - просто нумерация строк;
RANK() - ранжирование строк - при одинаковом значении строкам присваивается один номер, с пропуском номеров;
DENSE_RANK() - ранжирование строк без пропуска номеров;
LAG() - выбирает строку, предшествующую текущей, если таковой нет - выдается NULL;
LEAD() - выбирает строку, следующую за текущей, если таковой нет - выдается NULL.
Пример
Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов.
Фрагмент логической схемы базы данных:
 
Запрос:
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
Результат:
Query result:
+--------------+------------+-------+
| student_name | Kоличество | Номер |
+--------------+------------+-------+
| student_60   | 32         | 1     |
| student_15   | 30         | 2     |
| student_18   | 30         | 3     |
| student_27   | 30         | 4     |
| student_30   | 30         | 5     |
| student_31   | 30         | 6     |
| student_36   | 30         | 7     |
              ...
| student_5    | 9          | 61    |
| student_63   | 9          | 62    |
| student_29   | 8          | 63    |
| student_47   | 8          | 64    |
+--------------+------------+-------+
Affected rows: 64
В этом запросе после того, как были выбраны все студенты, посчитаны их шаги с правильными ответами, с помощью оконной функции была выполнена сортировка по количеству верных шагов (count(DISTINCT step_id))  и пронумерованы строки (функция ROW_NUMBER()).
Дополнительно ранжируем студентов.
Запрос:
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер,

    RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Ранг,
    DENSE_RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Рейтинг

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
Результат:
+--------------+------------+-------+------+---------+
| student_name | Kоличество | Номер | Ранг | Рейтинг |
+--------------+------------+-------+------+---------+
| student_60   | 32         | 1     | 1    | 1       |
| student_15   | 30         | 2     | 2    | 2       |
| student_18   | 30         | 3     | 2    | 2       |
| student_27   | 30         | 4     | 2    | 2       |
| student_30   | 30         | 5     | 2    | 2       |
| student_31   | 30         | 6     | 2    | 2       |
| student_36   | 30         | 7     | 2    | 2       |
| student_39   | 30         | 8     | 2    | 2       |
| student_4    | 30         | 9     | 2    | 2       |
| student_43   | 30         | 10    | 2    | 2       |
| student_44   | 30         | 11    | 2    | 2       |
| student_46   | 30         | 12    | 2    | 2       |
| student_49   | 30         | 13    | 2    | 2       |
| student_51   | 30         | 14    | 2    | 2       |
| student_53   | 30         | 15    | 2    | 2       |
| student_59   | 29         | 16    | 16   | 3       |
| student_9    | 29         | 17    | 16   | 3       |
| student_23   | 28         | 18    | 18   | 4       |
| student_50   | 27         | 19    | 19   | 5       |
                        ...
| student_5    | 9          | 61    | 60   | 15      |
| student_63   | 9          | 62    | 60   | 15      |
| student_29   | 8          | 63    | 63   | 16      |
| student_47   | 8          | 64    | 63   | 16      |
+--------------+------------+-------+------+---------+
Affected rows: 64
С помощью функции RANK() и DENSE_RANK() все студенты, имеющие 30  верно пройденных шагов, получили ранг 2 и  рейтинг 2. Студентам с 29 балами присвоен ранг 16 и  рейтинг 3.
Пример
Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент.
Запрос:
SELECT student_name, count(DISTINCT step_id) AS Количество,

       LAG(count(DISTINCT step_id)) 
       OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
Результат:
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | None    |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |

| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
Так как у первой записи нет предыдущей - значение разницы NULL. Заменим ее на 0 с помощью функции:
IFNULL(выражение, результат)
которая возвращает результат, если выражение равно NULL, и само выражение в противном случае.
Запрос:
SELECT student_name, count(DISTINCT step_id) AS Количество,

       IFNULL(LAG(count(DISTINCT step_id)) 
              OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id), 
              0) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
 Результат:
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | 0       |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |
              ...
| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
Оконные функции – то, что должен знать каждый T-SQL программист. Часть 1.
6 декабря 2018 г.
Еще в Microsoft SQL Server 2005 появился интересный функционал – оконные функции. Это функции, которые позволяют осуществлять вычисления в заданном диапазоне строк внутри предложения Select. Для тех, кто не сталкивался с этими функциями возникает вопрос – «Что значит оконные?». Окно – значит набор строк, в рамках которого происходит вычисление. Оконная функция позволяет разбивать весь набор данных на такие окна.
Конечно, все что могут оконные функции возможно реализовать и без них. Однако оконные функции обладают большим преимуществом перед регулярными агрегатными функциями: нет нужды группировать набор данных для расчетов., что позволяет сохранить все строки набора с их уникальными идентификаторами. При этом результаты работы оконных функций просто добавляются к результирующей выборке как еще одно поле.
Основное преимущество использования оконных функций над регулярными агрегатными функциями заключается в следующем: оконные функции не приводят к группированию строк в одну строку вывода, строки сохраняют свои отдельные идентификаторы, а агрегированное значение добавляется к каждой строке.
Окно определяется с помощью инструкции OVER(). Давайте рассмотрим синтаксис этой инструкции:
Оконная функция (столбец для вычислений) OVER ([PARTITION BY столбец для группировки] [ORDER BY столбец для сортировки] [ROWS или RANGE выражение для ограничения строк в пределах группы])
Ассортимент функций мы рассмотрим во второй части статьи. Скажу лишь, что они разделяются на: агрегирующие, ранжирующие, смещения.
Для демонстрации работы оконных функций предлагаю на тестовой таблице:
1
2
3
4
5
6
7
	CREATE TABLE ForWindowFunc (ID INT, GroupId INT, Amount INT)
GO
 
INSERT INTO ForWindowFunc (ID, GroupId, Amount)
 VALUES(1, 1, 100), (1, 1, 200), (1, 2, 150),
 (2, 1, 100), (2, 1, 300), (2, 2, 200), (2, 2, 50),
 (3, 1, 150), (3, 2, 200), (3, 2, 10);
 
ID	GroupId	Amount
1	1	100
1	1	200
1	2	150
2	1	100
2	1	300
2	2	200
2	2	50
3	1	150
3	2	200
Как видно, здесь три группы в колонке ID и две подгруппы в колонке GroupId с разным количеством элементов в группе.
Чаще всего используется функция суммирования, поэтому демонстрацию проведем именно на ней. Давайте посмотрим, как работает инструкция OVER:
1
2
3
	 SELECT ID,
 Amount,
 SUM(Amount) OVER() AS SUM FROM ForWindowFunc
 
ID	Amount	Sum
1	100	1310
1	200	1310
2	100	1310
2	300	1310
2	200	1310
2	50	1310
3	150	1310
3	200	1310
3	10	1310
Мы использовали инструкцию OVER() без предложений. В таком варианте окном будет весь набор данных и никакая сортировка не применяется. Нам просто повезло, что данные вывелись в том же порядке, в котором были вставлены в таблицу, но SQL Server может поменять порядок отображения, если нет явно заданной сортировки. Поэтому инструкцию OVER() практически никогда не применяют без предложений. Но, обратим наше внимание на новый столбец SUM. Для каждой строки выводится одно и то же значение 1310. Это сквозная сумма всех значений колонки Amount.
Предложение PARTITION BY
Предложение PARTITION BY определяет столбец, по которому будет производиться группировка, и он является ключевым в разбиении набора строк на окна.
Изменим наш запрос, написанный ранее, так:
1
2
3
	SELECT ID, 
 Amount, 
 SUM(Amount) OVER(PARTITION BY ID) AS SUM FROM ForWindowFunc
 
ID	Amount	Sum
1	100	300
1	200	300
2	100	650
2	300	650
2	200	650
2	50	650
3	150	360
3	200	360
3	10	360
Предложение PARTITION BY сгруппировало строки по полю ID. Теперь для каждой группы рассчитывается своя сумма значений Amount. Вы можете создавать окна по нескольким полям. Тогда в PARTITION BY нужно писать поля для группировки через запятую (например, PARTITION BY ID, Amount).
Предложение ORDER BY
Вместе с PARTITION BY может применяться предложение ORDER BY, которое определяет порядок сортировки внутри окна. Порядок сортировки очень важен, ведь оконная функция будет обрабатывать данные согласно этому порядку. Если вы не используете предложение PARTITION BY, а только ORDER BY, то окном будет весь набор данных.
1
2
3
4
	 SELECT ID,
 GroupId,
 Amount,
 SUM(Amount) OVER(PARTITION BY id ORDER BY Amount) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	100
1	2	150	250
1	1	200	450
2	2	50	50
2	1	100	150
2	2	200	350
2	1	300	650
3	2	10	10
3	1	150	160
3	2	200	360
К предложению PARTITION BY добавилось ORDER BY по полю Amount. Таким образом мы указали, что хотим видеть сумму не всех значений Amount в окне, а для каждого значения Amount сумму со всеми предыдущими. Такое суммирование часто называют нарастающий итог или накопительный итог.
Вы заметили, что в выборке появилось поле GpoupId. Это поле позволит показать, как изменится нарастающий итог, в зависимости от сортировки. Изменим запрос:
1
2
3
4
	SELECT ID, 
 GroupId, 
 Amount, 
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId, Amount) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	100
1	1	200	300
1	2	150	450
2	1	100	100
2	1	300	400
2	2	50	450
2	2	200	650
3	1	150	150
3	2	10	160
3	2	200	360
3	2	200	360
И мы получаем совсем другое поведение. И хоть в итоге для последнего значения в окне значения сходятся с предыдущим примером, но сумма для всех остальных отличается. Поэтому важно четко понимать, что вы хотите получить в итоге.
Предложение ROWS/RANG
Еще два предложения ROWS и RANGE применяются в инструкции OVER.  Этот функционал появился в MS SQL Server 2012.
Предложение ROWS ограничивает строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей. Оба предложения ROWS и RANGE используются вместе с ORDER BY.
Предложение ROWS может быть задано с помощью методов:
•	CURRENT ROW – отображение текущей строки;
•	UNBOUNDED FOLLOWING – все записи после текущей;
•	UNBOUNDED PRECEDING – все предыдущие записи;
•	<целое число> PRECEDING – заданное число предыдущих строк;
•	<целое число> FOLLOWING – заданное число последующих записей.
Вы можете комбинировать эти функции для достижения желаемого результата, например:
•	ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING – в окно попадут текущая и одна следующая запись;
1
2
3
4
	SELECT ID, 
 GroupId, 
 Amount, 
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId, Amount ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING ) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	300
1	1	200	350
1	2	150	150
2	1	100	400
2	1	300	350
2	2	50	250
2	2	200	200
3	1	150	160
3	2	10	210
3	2	200	200
Здесь, сумма рассчитывается по текущей и следующей ячейке в окне. А последняя в окне строка имеет то же значение, что и Amount. Посмотрим на первое окно, выделенное голубым цветом. Сумма 300 рассчитана сложением 100 и 200. Для следующего значения ситуация аналогичная. А последняя в окне сумма имеет значение 150, потому что текущий Amount больше не с чем складывать.
•	ROWS BETWEEN 1 PRECEDING AND CURRENT ROW – одна предыдущая и текущая запись
1
2
3
4
	SELECT ID, 
 GroupId, 
 Amount, 
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId, Amount ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	100
1	1	200	300
1	2	150	350
2	1	100	100
2	1	300	400
2	2	50	350
2	2	200	250
3	1	150	150
3	2	10	160
3	2	200	210
В этом запросе мы получаем сумму путем сложения текущего значения Amount и предыдущего. Первая строка имеет значение 100, т.к. предыдущего значения Amount не существует.
Предложение RANGE предназначено также для ограничения набора строк. В отличие от ROWS, оно работает не с физическими строками, а с диапазоном строк в предложении ORDER BY. Это означает, что одинаковые по рангу строки в контексте предложения ORDER BY будут считаться как одна текущая строка для функции CURRENT ROW. А в предложении ROWS текущая строка – это одна, текущая строка набора данных.
Предложение RANGE может использоваться только с опциями CURRENT ROW, UNBOUNDED PRECEDING и UNBOUNDED FOLLOWING.
Предложение RANGE может использовать опции:
•	CURRENT ROW – отображение текущей строки;
•	UNBOUNDED FOLLOWING – все записи после текущей;
•	UNBOUNDED PRECEDING – все предыдущие записи.
И не может:
•	<целое число> PRECEDING – заданное число предыдущих строк;
•	<целое число> FOLLOWING – заданное число последующих записей.
Примеры:
•	RANGE CURRENT ROW;
1
2
3
4
	SELECT ID,
 GroupId,
 Amount,
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId RANGE CURRENT ROW) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	300
1	1	200	300
1	2	150	150
2	1	100	400
2	1	300	400
2	2	200	250
2	2	50	250
3	1	150	150
3	2	200	210
3	2	10	210
Предложение Range настроено на текущую строку. Но, как мы помним, для Range текущая строка, это все строки, соответствующие одному значению сортировки. Сортировка в данном случае по полю GroupId. Первые две строки первого окна имеют значение GroupId равное 1 – следовательно оба эти значения удовлетворяют ограничению RANGE CURRENT ROW. Поэтому Sum для каждой из этих строк равна общей сумме Amount по ним - 300.
•	RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW;
1
2
3
4
	SELECT ID,
 GroupId,
 Amount,
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	1	100	300
1	1	200	300
1	2	150	450
2	1	100	400
2	1	300	400
2	2	200	650
2	2	50	650
3	1	150	150
3	2	200	360
3	2	10	360
В этом случае ограничение по всем предыдущим строкам и текущей. Для первой и второй строки это правило работает как предыдущее (вспоминаем CURRENT ROW), а для третьей как сумма Amount предыдущих строк с текущей.
•	RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING.
1
2
3
4
	SELECT ID, 
 GroupId, 
 Amount, 
 SUM(Amount) OVER(Partition BY id ORDER BY GroupId RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS SUM FROM ForWindowFunc
 
ID	GroupId	Amount	Sum
1	2	150	150
1	1	100	450
1	1	200	450
2	2	200	250
2	2	50	250
2	1	100	650
2	1	300	650
3	2	200	210
3	2	10	210
3	1	150	360
Это ограничение позволило нам получить сумму из текущей строки и всех предыдущих в рамках одного окна. Так как вторая и третья строка у нас в одной GroupId, то эти значения и есть Current Row. Поэтому они просуммированы сразу.
На этом закончим первую часть статьи. А напоследок - пример использования оконной функции из реальной практики.
Лучше всего понять суть оконных функций можно на примере. Допустим у вас есть данные о платежах абонентов. Платеж поступает на договор. Но у этого договора есть дочерние договора, на которых отрицательный баланс. И мы хотим распределить поступившие средства на погашение долга дочерних договоров.
Таким образом, нам нужно определить сколько же денег мы спишем со счета основного договора и сколько переведем на дочерний. Давайте посмотрим на таблицу:
ContractId	ChildContractId	PayId	CustAccount	PayAmount
1000000000	1000000002	1000000752	-200,00	800,00
1000000000	1000000003	1000000753	-1000,00	800,00
Где, ContractId – идентификатор основного договора,
ChildContractId – идентификатор дочернего договора,
PayId – идентификатор платежа,
CustAccount – баланс дочернего договора,
PayAmount – платеж.
Из таблицы видно, что для каждого дочернего договора сумма платежа 800. Это из-за того, что платеж на родительском договоре.
Так что наша задача рассчитать суммы переносов денег с родительского на дочерние договора.
Для этого суммируем CustAccount и PayAmount. Однако, простая сумма баланса и платежа нас не устраивает. Ведь на погашение долга на втором дочернем договоре мы должны учитывать остаток от суммы баланса первого договора и платежа.
Как мы можем действовать в этой ситуации?  Мы могли бы выбрать:
1
2
3
4
5
6
7
8
	SELECT
ContractId,
ChildContractId,
PayId,
CustAccount,
PayAmount,
PayAmount + (SELECT SUM(CustAccount) FROM dbo.Pays p2 WHERE p1.PayId = p2.PayId AND p2.ChildContractId <= p1.ChildContractId) AS [SUM]
FROM dbo.Pays p1
Этот запрос решает поставленную задачу, но подзапрос портит всю картину – увеличивает время выполнения запроса. Применим оконную функцию сложения:
1
2
3
4
5
6
7
8
	SELECT
ContractId,
ChildContractId,
PayId,
CustAccount,
PayAmount,
PayAmount + SUM(CustAccount) OVER (ORDER BY ChildContractId) AS [SUM]
FROM dbo.Pays p1
Этот вариант работает быстрее и выглядит лаконичнее. В нашем случае мы получаем сумму по полю CustAccount в окне, которое формируется по полю ChildContractId.
Результатом этих запросов будет таблица:
ContractId	ChildContractId	PayId	CustAccount	PayAmount	Sum
1000000000	1000000002	1000000752	-200,00	800,00	600
1000000000	1000000003	1000000753	-1000,00	800,00	-400
Исходя из полученных данных в колонке Sum мы определяем сумму, которую нужно перенести с родительского договора на дочерний. Для договора 1000000002 мы погасили долг полностью, так что сумма платежа 200р. Для договора 1000000003 долг погашен частично – сумма платежа равна сумме баланса и остатка от платежа после расчета для первой записи (-1000 + 600 = -400р).

